### 7.17 행위 패턴 145p

객체 간 의사소통을 돕는 패턴.

- 관찰자 패턴
- 중재자 패턴
- 커맨드 패턴


### 7.18 관찰자 패턴 145p

Observer 패턴은 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴

> RxJS 같다는 생각이 문득 드네용 <br/>
> 저번에 명철님이 하셨던 주가 모니터링 과제..? 도 생각나구요!


#### 7.18.1 관찰자 패턴과 발행/구독 패턴의 차이점 151p

- 관찰자 패턴에선 Subject 와 Observer 가 강하게 엮임
- 발행/구독은 특정 이벤트에 대해서만 알림을 받음 - 느슨한 결합을 도모

#### 7.18.2 장점 153p

- 클래스 간 강결합을 피하며 일관성을 유지해야 하는 상황에서 사용
- 다른 객체들의 구현 방식과 상관없이 알림을 보내야 하는 경우
- 시스템의 구성요소 간 결합도를 낮추는 훌륭한 도구.

#### 7.18.3 단점 154p

- 기대하는 대로 동작하고 있다는 것을 보장하기 어려움
  - 발행자와 구독자의 연결이 분리되어 있기 때문에, 구독자의 에러를 발행자가 알 수 없음
- 구독자들이 서로를 모르기 때문에 발행자를 변경하는데 드는 비용을 파악할 수 없음
- 구독자와 발행자의 관계가 동적으로 형성되기 때문에 의존성 추적이 힘듬

#### 7.18.4 발행/구독 패턴 구현하기 155p

> 흥미로워보이는데, 적용하기까진 쉽지않아보이네요. 그래도 적용하면 꽤 깔끔할 것 같은데요? <br />
> 다들 생각나는, 적용할 포인트 있으실까요?

### 7.19 중재자 패턴 166p

- 이벤트 발생시 특정 객체를 통해 다른 객체들에게 알림을 보내는 패턴
- 중앙 집중식 통제
- 다른 예로는 이벤트 버블링을 통한 이벤트 위임이 있음

> 이벤트 위임을 예로 드니까 바로 이해가 되네용

#### 7.19.1 간단한 중재자 구현 168p 

> 좀 더 절차적인 느낌이네요. 리액트의 `useReducer` 느낌이랄까요..?

#### 7.19.2 유사점과 차이점 169p

- 비즈니스 로직의 처리
  - 이벤트 집합은 소스와 핸들러에 직접 구현
  - 중재자 패턴은 중재자 내부에 구현

#### 7.19.3 이벤트 집합 패턴의 활용 171p

- backbone.js 의 컬렉션, 모델에서 활용
- jQuery 에서 on 메서드를 활용

#### 7.19.4 중재자 패턴의 활용 172p

- 마법사 형식의 인터페이스
- 개별 뷰 간의 직접참조로 인한 강한 결합을 방지
- 세부사항에서 워크플로를 추출함으로써 상위 레벨에서 워크플로를 자연스럽게 추상화

> 약간.. 설문 퍼널을 묶어두는 컨테이너 구현할때 쓰던 방식 같기도 하구, <br />
> 제가 선호하는 방식인 "페이지 컴포넌트에서 비즈니스 로직을 다 처리한다" 와도 비슷한 결인 것 같아요. <br />
> 다른 분들은 어디서 비슷한 모양새를 느끼셨나요?

#### 7.19.5 이벤트 집합 패턴(발행/구독)과 중재자 패턴 결합하기 173p

#### 7.19.6 최신 자바스크립트에서의 중재자 패턴과 미들웨어 174p

#### 7.19.7 중재자 패턴 vs 퍼사드 패턴 175p

- 중재자 패턴은 모듈이 명시적으로 참조함으로써 모듈 간의 상호작용을 중앙집중화 - 다방향성
- 퍼사드 패턴은 인터페이스를 제공하지만 추가 기능을 구현하지는 않음, 다른 모듈은 퍼사드 구현 내용을 인지하지 못함 - 단방향성

### 7.20 커맨드 패턴 176p

- 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화해 추후에 실행토록 함
- 명령을 실행하는 객체와 호출하는 객체 간의 결합을 느슨하게 함


### 7.21 마치며 178p

- 위 패턴들은 도메인 특화 객체 설계에 효과적

## 자바스크립트 MV* 패턴

### 8.1 MVC 패턴 180p

- 비즈니스 데이터(Model) 와 UI(View)를 분리하고 컨트롤러(C)가 로직과 입력을 관리하는 구조

#### 8.1.1 Smalltalk-80의 MVC 패턴 181p

- 애플리케이션 로직과 UI를 분리하는 것이 목표
- 분리함으로써 다른 인터페이스에서도 재사용
- 특징
  - Model: 도메인 관련 데이터를 표현, UI에 대해서는 관여 X, 변경시 Observer 에게 푸시
  - View: 모델의 현재 상태를 표현, 관찰자 패턴을 활용해 변경을 알 수 있게 함. 각 섹션 또는 요소에는 뷰 - 컨트롤러 쌍이 존재
  - Controller: 키보드 입력이나 클릭 같은 상호작용을 처리, 뷰에 무엇을 보여줄지 결정하는 역할

### 8.2 자바스크립트의 MVC 182p

- Backbone.js, Ember.js, AngularJS 가 지원함

#### 8.2.1 모델 183p

- 애플리케이션의 데이터를 관리하는 역할
- 모델은 주로 비즈니스 데이터와 관련

#### 8.2.2 뷰 184p

- 모델의 시각적 표현
- 편집과 업데이트 기능을 제공
- 모델을 실제로 업데이트하는 작업은 컨트롤러가 담당

#### 8.2.3 템플릿 186p

#### 8.2.4 컨트롤러 189p

### 8.3 MVC를 사용하는 이유는? 189p

- 전반적인 유지보수의 단순화
- 모델과 뷰의 분리
- 중복 코드 제거
- 코어 로직과 UI 동시 개발 가능

### 8.4 자바스크립트와 Smalltalk-80의 MVC 190p

- 순수한 형태의 MVC 를 고수하는 Maria.js
- MVC의 또 다른 관점
  - GoF는 MVC 를 패턴이 아닌 UI 를 구축하기 위한 클래스의 집합으로 간주
  - 관찰자, 전략, 컴포지트 세 가지 디자인 패턴의 변형으로 봄

### 8.5 MVC 정리 191p

### 8.6 MVP 패턴 191p

- MVC 의 파생 패턴
- P 는 Presenter, 뷰에 대한 UI 비즈니스 로직을 담당
- MVC와 달리 뷰에서의 이벤트 호출은 프리젠터로 위임
- 수동형 아키텍처
- 뷰와 모델간의 분리를 더욱 명확하게 해줌, 그러나 데이터 바인딩이 지원되지 않음

#### 8.6.2 MVP vs MVC 193p

- MVP 는 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용
- 뷰가 복잡하고 상호작용이 많다면 MVC 가 적합하지 않음. 여러 컨트롤러에 크게 의존해야 할 수 있기 때문
- MVC 보다 MVP 가 단위테스트에 용이함

### 8.7 MVVM 패턴 194p

- 선언적 데이터 바인딩을 활용해 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 함

#### 8.7.1 역사 195p

#### 8.7.2 모델 196p

- 모델은 정보만 담고 있음
- 동작은 뷰모델에서 캡슐화해 처리해야 하는 비즈니스 로직으로 간주
- 데이터 유효성 검사는 모델에서 수행하는 것이 허용됨

#### 8.7.3 뷰 196p

- 사용자가 상호작용하는 유일한 부분
- 능동적으로 볼 수 있지만 수동적일 수도 있음
- 데이터 바인딩, 이벤트, 동작들을 포함하고 있음

#### 8.7.4 뷰모델 197p

- 데이터 변환기 역할을 하는 컨트롤러
- 뷰와 모델을 잇는 다리 역할을 수행

#### 8.7.5 뷰와 뷰모델 복습 198p

- 뷰와 뷰모델은 양방향 데이터 바인딩과 이벤트를 통해 소통
- 뷰모델은 데이터 유효성 검사 같은 다른 메서드와 기능에 대한 접근도 허용

#### 8.7.6 뷰모델 vs 모델 198p

- 뷰모델은 데이터 바인딩을 위해 모델 또는 속성을 가져올 수 있음
- 뷰에 제공되는 속성을 가져오거나 조작하기 위ㅣ한 인터페이스를 포함할 수 있음

### 8.8 장단점 198p

#### 8.8.1 장점 198p

- UI 와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 함
- 뷰를 추상화 함으로써 비즈니스 로직의 양을 줄임

#### 8.8.2 단점 199p

- 단순한 UI의 경우 과도한 구현이 될 수 있음
- 선언적이고 편리할 수 있지만 디버깅이 어려울 수 있음

### 8.9 MVC vs MVP vs MVVM 199p

- MVC 에서 파생된 패턴
- 핵심 차이점은 각 계층이 다른 계층에 대해 갖는 의존성과 결합도의 차이에 있음
- MVC 에선 뷰는 모델에 직접 접근할 수 있음, 하지만 전체 모델을 뷰에 노출하는 것은 성능 및 보안 문제를 일으킬 수 있음
- 이를 피하기 위한게 MVVM 패턴
- MVP 에선 프리젠터가 컨트롤러 역할을 대체
- MVVM 을 사용하면 뷰와 관련된 모델 일부를 생성할 수 있고, 이를 통해 모델을 뷰에 노출하는 것을 피할 수 있음
- 뷰모델은 뷰를 참조할 필요가 없음

### 8.10 최신 MV* 패턴

- Vue.js 는 MVVM 패턴이라 주장..?

#### 8.10.1 MV* 패턴과 리액트

- 리액트는 MVC 프레임워크가 아님, UI 구축을 위한 라이브러리
- MVC를 수평적으로 나누는 대신, 관심사에 따라 수직적으로 나눔
- 상태(Model), 렌더링(View), 제어 흐름 로직(소규모의 지역화된 컨트롤러) 를 담고 있는 작은 수직 분할형 MVC로 볼 수 있음

### 8.11 마치며




